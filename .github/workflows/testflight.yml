name: Deploy to TestFlight

on:
  workflow_dispatch:
    inputs:
      build_version:
        description: 'Build version (e.g., 1.0.0+1)'
        required: true
        default: '1.0.0+1'
  push:
    branches: [ master ]
    paths: [ '.trigger-testflight' ]
      release_notes:
        description: 'Release notes for TestFlight'
        required: false
        default: 'Bug fixes and improvements'
      skip_version_bump:
        description: 'Skip automatic version bumping'
        type: boolean
        required: false
        default: false

jobs:
  deploy-testflight:
    name: Deploy to TestFlight
    runs-on: macos-14
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Select Xcode version
      run: |
        sudo xcode-select -s /Applications/Xcode_15.4.app/Contents/Developer
        xcodebuild -version
        
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.24.3'
        cache: true
        cache-key: 'flutter-:os:-:channel:-:version:-:arch:-:hash:'
        cache-path: '${{ runner.tool_cache }}/flutter/:channel:-:version:-:arch:'
        
    - name: Cache Pub Dependencies
      uses: actions/cache@v4
      with:
        path: |
          ${{ env.PUB_CACHE }}
          ~/.pub-cache
          **/.dart_tool
        key: pub-cache-${{ runner.os }}-${{ hashFiles('**/pubspec.lock') }}
        restore-keys: |
          pub-cache-${{ runner.os }}-
          
    - name: Cache iOS Pods
      uses: actions/cache@v4
      with:
        path: ios/Pods
        key: pods-${{ runner.os }}-${{ hashFiles('ios/Podfile.lock') }}
        restore-keys: |
          pods-${{ runner.os }}-
        
    - name: Install dependencies
      run: flutter pub get
      
    - name: Update version in pubspec.yaml
      if: ${{ !inputs.skip_version_bump }}
      run: |
        echo "üìù Updating version to: ${{ inputs.build_version }}"
        
        # Parse version and build number
        VERSION_INPUT="${{ inputs.build_version }}"
        if [[ "$VERSION_INPUT" == *"+"* ]]; then
          VERSION_NAME=${VERSION_INPUT%+*}
          BUILD_NUMBER=${VERSION_INPUT#*+}
        else
          VERSION_NAME="$VERSION_INPUT"
          BUILD_NUMBER=$(date +%s)
          echo "‚ö†Ô∏è No build number provided, using timestamp: $BUILD_NUMBER"
        fi
        
        echo "Version Name: $VERSION_NAME"
        echo "Build Number: $BUILD_NUMBER"
        
        # Update pubspec.yaml
        sed -i.bak "s/^version: .*/version: $VERSION_NAME+$BUILD_NUMBER/" pubspec.yaml
        
        # Verify the change
        echo "‚úÖ Updated pubspec.yaml version:"
        grep "^version:" pubspec.yaml
        
        # Store for later steps
        echo "VERSION_NAME=$VERSION_NAME" >> $GITHUB_ENV
        echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
        
    - name: Generate release notes file
      run: |
        echo "üìã Generating release notes..."
        
        # Get current date
        RELEASE_DATE=$(date "+%Y-%m-%d")
        
        # Create release notes file
        cat > ios/release_notes.txt << EOF
        ${{ inputs.release_notes }}
        
        Version: ${{ env.VERSION_NAME || inputs.build_version }}
        Build: ${{ env.BUILD_NUMBER || github.run_number }}
        Released: $RELEASE_DATE
        
        Automated build from GitHub Actions
        Commit: ${{ github.sha }}
        EOF
        
        echo "‚úÖ Release notes created:"
        cat ios/release_notes.txt
      
    - name: Setup iOS Certificates
      env:
        IOS_CERTIFICATE_BASE64: ${{ secrets.IOS_CERTIFICATE_BASE64 }}
        IOS_CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
        IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create certificate and provisioning profile files
        echo "$IOS_CERTIFICATE_BASE64" | base64 --decode > certificate.p12
        echo "$IOS_PROVISIONING_PROFILE_BASE64" | base64 --decode > profile.mobileprovision
        
        # Verify certificate file integrity
        if ! openssl pkcs12 -in certificate.p12 -passin pass:"$IOS_CERTIFICATE_PASSWORD" -noout -info; then
          echo "‚ùå Certificate verification failed. Check IOS_CERTIFICATE_PASSWORD."
          exit 1
        fi
        echo "‚úÖ Certificate file verified successfully."
        
        # Create and configure keychain with more robust settings
        security delete-keychain build.keychain 2>/dev/null || true
        security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
        security set-keychain-settings -lut 21600 build.keychain
        security list-keychains -d user -s build.keychain $(security list-keychains -d user | sed s/\"//g | tr '\n' ' ')
        security default-keychain -s build.keychain
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
        
        # Improved certificate import with better error handling
        echo "üîê Importing iOS Distribution Certificate..."
        if security import certificate.p12 -k build.keychain -P "$IOS_CERTIFICATE_PASSWORD" -A -t cert; then
          echo "‚úÖ Certificate imported successfully via direct P12 import"
        else
          echo "‚ö†Ô∏è P12 import failed, trying PEM conversion..."
          # Fallback to PEM conversion
          openssl pkcs12 -in certificate.p12 -clcerts -nokeys -out cert.pem -passin pass:"$IOS_CERTIFICATE_PASSWORD"
          openssl pkcs12 -in certificate.p12 -nocerts -nodes -out key.pem -passin pass:"$IOS_CERTIFICATE_PASSWORD"
          
          security import cert.pem -k build.keychain -T /usr/bin/codesign -A
          security import key.pem -k build.keychain -T /usr/bin/codesign -A
          echo "‚úÖ Certificate imported via PEM conversion"
        fi
        
        # Set key partition list to allow codesign access
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
        
        # Verify certificate is installed
        security find-identity -v -p codesigning build.keychain
        
        # Install provisioning profile with validation
        echo "üì± Installing Provisioning Profile..."
        PROFILE_UUID=$(security cms -D -i profile.mobileprovision | grep -A 1 "UUID" | tail -1 | sed 's/.*<string>//' | sed 's/<\/string>.*//' | xargs)
        PROFILE_NAME=$(security cms -D -i profile.mobileprovision | grep -A 1 -B 1 "Name" | grep string | sed 's/.*<string>//' | sed 's/<\/string>.*//')
        
        echo "Profile UUID: $PROFILE_UUID"
        echo "Profile Name: $PROFILE_NAME"
        
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        cp profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/${PROFILE_UUID}.mobileprovision
        
        # Verify provisioning profile installation
        ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
        echo "‚úÖ Provisioning profile installed successfully"
        
    - name: Install CocoaPods dependencies
      run: |
        cd ios
        pod install --repo-update
        
    - name: Build iOS for App Store
      run: |
        export IPHONEOS_DEPLOYMENT_TARGET=12.0
        flutter build ios --release --no-codesign
        
    - name: Archive iOS App
      run: |
        cd ios
        xcodebuild -workspace Runner.xcworkspace \
          -scheme Runner \
          -configuration Release \
          -destination 'generic/platform=iOS' \
          -archivePath Runner.xcarchive \
          CODE_SIGN_STYLE=Manual \
          DEVELOPMENT_TEAM=${{ secrets.APP_STORE_CONNECT_TEAM_ID }} \
          CODE_SIGN_IDENTITY="iPhone Distribution: Morris Merkel (${{ secrets.APP_STORE_CONNECT_TEAM_ID }})" \
          PROVISIONING_PROFILE_SPECIFIER="Morris Merkel" \
          archive
          
    - name: Export IPA
      run: |
        cd ios
        cat > ExportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
          <key>destination</key>
          <string>export</string>
          <key>method</key>
          <string>app-store</string>
          <key>teamID</key>
          <string>${{ secrets.APP_STORE_CONNECT_TEAM_ID }}</string>
          <key>uploadBitcode</key>
          <false/>
          <key>uploadSymbols</key>
          <true/>
          <key>signingStyle</key>
          <string>manual</string>
          <key>provisioningProfiles</key>
          <dict>
            <key>com.lumengarten.lumengartenApp</key>
            <string>Morris Merkel</string>
          </dict>
        </dict>
        </plist>
        EOF
        
        xcodebuild -exportArchive \
          -archivePath Runner.xcarchive \
          -exportPath . \
          -exportOptionsPlist ExportOptions.plist
          
    - name: Upload to TestFlight
      env:
        APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
        APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        APP_STORE_CONNECT_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}
      run: |
        cd ios
        
        # Create API key file with proper permissions
        echo "üîë Setting up App Store Connect API Key..."
        echo "$APP_STORE_CONNECT_PRIVATE_KEY" | base64 --decode > AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8
        chmod 600 AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8
        
        API_KEY_PATH="$(pwd)/AuthKey_$APP_STORE_CONNECT_API_KEY_ID.p8"
        echo "API Key Path: $API_KEY_PATH"
        
        # Verify API key file exists and is valid
        if [[ ! -f "$API_KEY_PATH" ]]; then
          echo "‚ùå API Key file not found: $API_KEY_PATH"
          exit 1
        fi
        
        if [[ ! -s "$API_KEY_PATH" ]]; then
          echo "‚ùå API Key file is empty"
          exit 1
        fi
        
        echo "‚úÖ API Key file verified: $(wc -c < "$API_KEY_PATH") bytes"
        
        # Verify IPA file exists
        if [[ ! -f "Runner.ipa" ]]; then
          echo "‚ùå IPA file not found: Runner.ipa"
          ls -la
          exit 1
        fi
        
        IPA_SIZE=$(wc -c < "Runner.ipa")
        echo "‚úÖ IPA file verified: ${IPA_SIZE} bytes ($(echo "scale=1; $IPA_SIZE / 1024 / 1024" | bc)MB)"
        
        # Primary upload method: xcrun altool (most reliable)
        echo "üöÄ Uploading to TestFlight using altool..."
        if xcrun altool --upload-app \
          --type ios \
          --file "Runner.ipa" \
          --apiKey "$APP_STORE_CONNECT_API_KEY_ID" \
          --apiIssuer "$APP_STORE_CONNECT_ISSUER_ID" \
          --apiKeyPath "$API_KEY_PATH"; then
          echo "‚úÖ Successfully uploaded to TestFlight via altool"
          exit 0
        else
          echo "‚ö†Ô∏è altool upload failed, trying notarytool..."
        fi
        
        # Fallback method: notarytool (newer alternative)
        if command -v xcrun notarytool &> /dev/null; then
          echo "üîÑ Trying notarytool upload..."
          if xcrun notarytool submit "Runner.ipa" \
            --key "$API_KEY_PATH" \
            --key-id "$APP_STORE_CONNECT_API_KEY_ID" \
            --issuer "$APP_STORE_CONNECT_ISSUER_ID"; then
            echo "‚úÖ Successfully uploaded to TestFlight via notarytool"
            exit 0
          else
            echo "‚ö†Ô∏è notarytool upload also failed"
          fi
        fi
        
        # Final fallback: Store IPA as artifact for manual upload
        echo "‚ùå Automatic upload failed. IPA will be stored as artifact for manual TestFlight upload."
        echo "üì¶ Manual upload instructions:"
        echo "1. Download the 'ios-app-store-ipa' artifact from this workflow run"
        echo "2. Open Xcode -> Window -> Organizer"
        echo "3. Drag Runner.ipa to the Archives tab"
        echo "4. Click 'Distribute App' -> 'App Store Connect' -> 'Upload'"
        echo "5. Follow the TestFlight upload wizard"
        
        # Don't fail the workflow - let it complete with artifact upload
        exit 0
          
    - name: Upload IPA Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ios-app-store-ipa-${{ env.VERSION_NAME || inputs.build_version }}
        path: ios/Runner.ipa
        
    - name: Upload Release Notes Artifact
      uses: actions/upload-artifact@v4
      with:
        name: release-notes-${{ env.VERSION_NAME || inputs.build_version }}
        path: ios/release_notes.txt
        
    - name: Build Summary & Notifications
      if: always()
      run: |
        echo "## üöÄ TestFlight Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**App:** Lumengarten" >> $GITHUB_STEP_SUMMARY
        echo "**Version:** ${{ env.VERSION_NAME || inputs.build_version }}" >> $GITHUB_STEP_SUMMARY
        echo "**Build Number:** ${{ env.BUILD_NUMBER || github.run_number }}" >> $GITHUB_STEP_SUMMARY
        echo "**Bundle ID:** com.lumengarten.lumengartenApp" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** [${{ github.sha }}](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})" >> $GITHUB_STEP_SUMMARY
        echo "**Workflow:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check if IPA was created
        if [[ -f "ios/Runner.ipa" ]]; then
          IPA_SIZE=$(wc -c < "ios/Runner.ipa")
          IPA_SIZE_MB=$(echo "scale=2; $IPA_SIZE / 1024 / 1024" | bc)
          echo "**‚úÖ IPA Created:** ${IPA_SIZE_MB}MB" >> $GITHUB_STEP_SUMMARY
        else
          echo "**‚ùå IPA Creation:** Failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Check if upload was attempted
        if [[ "${{ job.status }}" == "success" ]]; then
          echo "**üéâ TestFlight Upload:** Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Check TestFlight for the new build" >> $GITHUB_STEP_SUMMARY
          echo "2. Add testers or make it available for review" >> $GITHUB_STEP_SUMMARY
          echo "3. Submit to App Store Review when ready" >> $GITHUB_STEP_SUMMARY
        else
          echo "**‚ö†Ô∏è TestFlight Upload:** Check logs for issues" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Manual Upload Instructions:" >> $GITHUB_STEP_SUMMARY
          echo "1. Download the IPA artifact from this workflow run" >> $GITHUB_STEP_SUMMARY
          echo "2. Open Xcode ‚Üí Window ‚Üí Organizer" >> $GITHUB_STEP_SUMMARY
          echo "3. Drag Runner.ipa to the Archives tab" >> $GITHUB_STEP_SUMMARY
          echo "4. Click 'Distribute App' ‚Üí 'App Store Connect' ‚Üí 'Upload'" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìã Release Notes:" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "${{ inputs.release_notes }}" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY