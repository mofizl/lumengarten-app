# Fastfile for Lumengarten iOS TestFlight Deployment

default_platform(:ios)

platform :ios do
  before_all do
    setup_ci
  end

  desc "Build and upload to TestFlight"
  lane :testflight do
    # Setup temporary keychain for CI - CRITICAL: default_keychain must be true for GitHub Actions
    create_keychain(
      name: "fastlane_tmp_keychain",
      password: ENV["KEYCHAIN_PASSWORD"],
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    # Import certificate - REQUIRED for signing
    UI.message("üîê Testing certificate file...")
    cert_path = ENV["IOS_CERTIFICATE_PATH"]
    UI.message("Certificate path: #{cert_path}")
    UI.message("Certificate exists: #{File.exist?(cert_path)}")
    if File.exist?(cert_path)
      UI.message("Certificate file size: #{File.size(cert_path)} bytes")
    end
    
    # Try multiple import methods
    UI.message("Trying different import methods...")
    
    # Method 1: Without -T flags
    begin
      sh("security import \"#{ENV['IOS_CERTIFICATE_PATH']}\" -k fastlane_tmp_keychain -P \"#{ENV['IOS_CERTIFICATE_PASSWORD']}\"")
      UI.success("Method 1 (no -T flags) worked!")
    rescue => e
      UI.error("Method 1 failed: #{e}")
      
      # Method 2: With different keychain path
      begin
        sh("security import \"#{ENV['IOS_CERTIFICATE_PATH']}\" -k ~/Library/Keychains/fastlane_tmp_keychain-db -P \"#{ENV['IOS_CERTIFICATE_PASSWORD']}\"")
        UI.success("Method 2 (different keychain path) worked!")
      rescue => e2
        UI.error("Method 2 failed: #{e2}")
        
        # Method 3: Import to login keychain, then copy
        begin
          sh("security import \"#{ENV['IOS_CERTIFICATE_PATH']}\" -P \"#{ENV['IOS_CERTIFICATE_PASSWORD']}\"")
          UI.success("Method 3 (login keychain) worked!")
        rescue => e3
          UI.error("All methods failed: #{e3}")
          raise "Certificate import completely failed"
        end
      end
    end
    
    # Debug: List available certificates in keychain
    UI.message("üîç Available certificates in keychain:")
    sh("security find-identity -v -p codesigning fastlane_tmp_keychain")

    install_provisioning_profile(
      path: ENV["IOS_PROVISIONING_PROFILE_PATH"]
    )
    
    # Get the UUID of the installed provisioning profile
    profile_uuid = sh("security cms -D -i \"#{ENV['IOS_PROVISIONING_PROFILE_PATH']}\" | plutil -extract UUID xml1 -o - - | sed -n 's/.*<string>\\(.*\\)<\\/string>.*/\\1/p'").strip
    UI.message("üì± Provisioning Profile UUID: #{profile_uuid}")

    # Update project settings for distribution
    update_project_team(
      path: "Runner.xcodeproj",
      teamid: ENV["DEVELOPMENT_TEAM"]
    )
    
    # Disable automatic signing and set manual signing with provisioning profile UUID
    update_code_signing_settings(
      path: "Runner.xcodeproj", 
      use_automatic_signing: false,
      targets: ["Runner"],
      code_sign_identity: "iPhone Distribution: Morris Merkel (QX8XC3CNTR)",
      profile_uuid: profile_uuid
    )

    # Set Flutter environment for CI FIRST
    ENV['FLUTTER_ROOT'] = '/Users/runner/hostedtoolcache/flutter/3.24.3/x64'
    ENV['PATH'] = "/opt/homebrew/bin:/usr/local/bin:#{ENV['FLUTTER_ROOT']}/bin:#{ENV['PATH']}"
    
    # Ensure CocoaPods uses correct Ruby version (from research)
    ENV['LANG'] = 'en_US.UTF-8'
    ENV['LC_ALL'] = 'en_US.UTF-8'
    
    # COMPREHENSIVE FIX: Ruby Environment and CocoaPods Installation (2024)
    UI.message("üîß Applying comprehensive Ruby 3.4.5 + macOS-14 compatibility fixes...")
    
    # Check if CocoaPods is working first
    cocoapods_working = false
    begin
      sh("which pod")
      sh("pod --version")
      UI.success("‚úÖ CocoaPods found and working!")
      cocoapods_working = true
    rescue => e
      UI.message("‚ö†Ô∏è CocoaPods not available or broken - implementing comprehensive fix...")
    end
    
    unless cocoapods_working
      # STEP 1: Force proper development tools configuration (Critical for macOS-14)
      UI.message("üîß Step 1: Ensuring development tools are properly configured...")
      begin
        # Verify Command Line Tools are selected correctly
        dev_path = sh("xcode-select -p").strip
        UI.message("Current developer path: #{dev_path}")
        
        # Force Command Line Tools selection if needed
        unless dev_path.include?("/Library/Developer/CommandLineTools")
          UI.message("üîÑ Forcing Command Line Tools selection...")
          sh("sudo xcode-select -s /Library/Developer/CommandLineTools")
        end
        
        # Verify compiler availability
        sh("which gcc && gcc --version")
        sh("which make && make --version")
        UI.success("‚úÖ Development tools verified")
        
      rescue => dev_error
        UI.error("‚ùå Development tools issue: #{dev_error}")
        UI.message("üö® Attempting to fix development tools...")
        sh("sudo xcode-select --install || echo 'Installation triggered'")
        sh("sleep 10")  # Allow some setup time
        sh("sudo xcode-select -s /Library/Developer/CommandLineTools")
      end
      
      # STEP 2: Set up proper Ruby environment with compilation flags
      UI.message("üîß Step 2: Setting up Ruby compilation environment...")
      ENV['CPPFLAGS'] = "-I$(brew --prefix)/include"
      ENV['LDFLAGS'] = "-L$(brew --prefix)/lib"
      ENV['PATH'] = "/opt/homebrew/bin:/usr/local/bin:#{ENV['PATH']}"
      
      # STEP 3: Install Ruby 3.4.5 standard library gems (CRITICAL)
      UI.message("üîß Step 3: Installing Ruby 3.4.5 standard library gems...")
      standard_gems = ["minitest", "drb", "mutex_m", "base64"]
      standard_gems.each do |gem_name|
        begin
          sh("gem install #{gem_name}")
          UI.message("‚úÖ #{gem_name} installed")
        rescue => gem_error
          UI.error("‚ùå Failed to install #{gem_name}: #{gem_error}")
        end
      end
      
      # STEP 4: Install bigdecimal with multiple fallback strategies
      UI.message("üîß Step 4: Installing bigdecimal (critical for CocoaPods)...")
      bigdecimal_installed = false
      
      # Strategy 1: Direct gem install with proper environment
      unless bigdecimal_installed
        begin
          sh("gem install bigdecimal")
          UI.success("‚úÖ bigdecimal installed successfully!")
          bigdecimal_installed = true
        rescue => e1
          UI.error("‚ùå Direct install failed: #{e1}")
        end
      end
      
      # Strategy 2: Install with compilation flags
      unless bigdecimal_installed
        begin
          sh("gem install bigdecimal -- --with-cflags='-Wno-error=incompatible-pointer-types'")
          UI.success("‚úÖ bigdecimal installed with compilation flags!")
          bigdecimal_installed = true
        rescue => e2
          UI.error("‚ùå Compilation flags method failed: #{e2}")
        end
      end
      
      # Strategy 3: Use Homebrew's Ruby directly
      unless bigdecimal_installed
        begin
          sh("brew install ruby")
          homebrew_gem = "/opt/homebrew/bin/gem"
          if File.exist?(homebrew_gem)
            sh("#{homebrew_gem} install bigdecimal")
            UI.success("‚úÖ bigdecimal installed via Homebrew Ruby!")
            bigdecimal_installed = true
          else
            homebrew_gem = "/opt/homebrew/lib/ruby/gems/3.4.0/bin/gem"
            if File.exist?(homebrew_gem)
              sh("#{homebrew_gem} install bigdecimal")
              UI.success("‚úÖ bigdecimal installed via Homebrew Ruby (alternative path)!")
              bigdecimal_installed = true
            end
          end
        rescue => e3
          UI.error("‚ùå Homebrew Ruby method failed: #{e3}")
        end
      end
      
      # Final check for bigdecimal
      unless bigdecimal_installed
        UI.error("üö® CRITICAL: bigdecimal installation failed with all methods!")
        UI.message("üîÑ Attempting to continue with system Ruby...")
      end
      
      # STEP 5: Install CocoaPods via Homebrew (most reliable method)
      UI.message("üîß Step 5: Installing CocoaPods via Homebrew...")
      begin
        sh("brew install --force --overwrite cocoapods")
        sh("brew link --overwrite cocoapods")
        
        # Verify CocoaPods is working
        sh("pod --version")
        UI.success("‚úÖ CocoaPods installed and working via Homebrew!")
        
      rescue => cocoapods_error
        UI.error("‚ùå CocoaPods installation failed: #{cocoapods_error}")
        raise "CocoaPods installation completely failed after comprehensive fixes"
      end
    end
    
    # Fastlane now handles the complete Flutter build
    UI.message("üî® Building Flutter iOS app via Fastlane...")
    sh("cd .. && flutter build ios --release --no-codesign")
    
    # Build signed IPA using Fastlane with extended timeout and CI optimizations
    UI.message("üî® Starting Xcode archive build with CI optimizations...")
    begin
      Timeout::timeout(2100) do  # 35 minute timeout (was 30)
        ipa_path = build_ios_app(
          workspace: "Runner.xcworkspace",
          scheme: "Runner",
          configuration: "Release",
          export_method: "app-store",
          export_options: {
            provisioningProfiles: {
              "com.lumengarten.lumengartenApp" => profile_uuid
            },
            signingStyle: "manual",
            uploadBitcode: false,
            uploadSymbols: true
          },
          output_directory: "fastlane/builds",
          output_name: "Lumengarten.ipa",
          # CI-specific optimizations:
          skip_build_archive: false,
          skip_codesigning: false,
          silent: false,
          suppress_xcode_output: false,
          xcargs: "-allowProvisioningUpdates -allowProvisioningDeviceRegistration"
        )
      end
    rescue Timeout::Error
      UI.error("üö® Xcode build timed out after 35 minutes")
      UI.message("‚ö†Ô∏è This usually indicates hanging Run Script phases")
      UI.message("‚úÖ Build Phase reordering has been applied - retry should work")
      raise "Build timeout - Build Phase fixes applied, retry recommended"
    end
    UI.message("Created signed IPA at: #{ipa_path}")
    
    # Debug environment variables
    UI.message("üîç Debug Environment Variables:")
    UI.message("APP_STORE_CONNECT_API_KEY_ID: #{ENV['APP_STORE_CONNECT_API_KEY_ID']}")
    UI.message("APP_STORE_CONNECT_API_KEY_PATH: #{ENV['APP_STORE_CONNECT_API_KEY_PATH']}")
    
    # Verify IPA exists before upload
    if File.exist?(ipa_path)
      UI.message("‚úÖ IPA file confirmed at: #{ipa_path}")
      
      # Check if API key file exists
      api_key_path = ENV["APP_STORE_CONNECT_API_KEY_PATH"]
      if api_key_path && File.exist?(api_key_path)
        UI.message("‚úÖ API Key file found at: #{api_key_path}")
      else
        UI.error("‚ùå API Key file not found at: #{api_key_path}")
        sh("find .. -name 'AuthKey*.p8' -type f")
      end
      
      # Debug environment access step by step
      UI.message("üîç Step 1: Accessing APP_STORE_CONNECT_API_KEY_ID...")
      
      begin
        key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
        UI.message("‚úÖ key_id retrieved: #{key_id.nil? ? 'NIL' : 'SET'}")
      rescue => e
        UI.error("‚ùå Failed to access APP_STORE_CONNECT_API_KEY_ID: #{e}")
        exit(1)
      end
      
      UI.message("üîç Step 2: Setting issuer_id...")
      issuer_id = "d439615c-03af-424b-8ed7-98abfae18d23"
      UI.message("‚úÖ issuer_id set: #{issuer_id}")
      
      UI.message("üîç Step 3: Accessing APP_STORE_CONNECT_API_KEY_PATH...")
      begin
        key_filepath = ENV["APP_STORE_CONNECT_API_KEY_PATH"]
        UI.message("‚úÖ key_filepath retrieved: #{key_filepath}")
      rescue => e
        UI.error("‚ùå Failed to access APP_STORE_CONNECT_API_KEY_PATH: #{e}")
        exit(1)
      end
      
      if key_id.nil? || key_id.empty?
        UI.error("‚ùå APP_STORE_CONNECT_API_KEY_ID is nil or empty!")
        exit(1)
      end
      
      # Upload signed IPA to TestFlight
      # Create API key object first, then use it for upload
      api_key = app_store_connect_api_key(
        key_id: key_id,
        issuer_id: issuer_id,
        key_filepath: key_filepath,
        duration: 1200,
        in_house: false
      )
      
      upload_to_testflight(
        api_key: api_key,
        app_identifier: "com.lumengarten.lumengartenApp",
        skip_waiting_for_build_processing: true,
        ipa: ipa_path
      )
    else
      UI.error("‚ùå IPA file not found at: #{ipa_path}")
      sh("ls -la fastlane/builds/")
    end

    # Cleanup
    delete_keychain(name: "fastlane_tmp_keychain")
  end

  desc "Alternative iOS build method - bypasses problematic Xcode Run Scripts"
  lane :testflight_alternative do
    # Setup identical to main testflight lane
    create_keychain(
      name: "fastlane_tmp_keychain",
      password: ENV["KEYCHAIN_PASSWORD"],
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    import_certificate(
      certificate_path: ENV["IOS_CERTIFICATE_PATH"],
      certificate_password: ENV["IOS_CERTIFICATE_PASSWORD"],
      keychain_name: "fastlane_tmp_keychain",
      keychain_password: ENV["KEYCHAIN_PASSWORD"]
    )
    
    install_provisioning_profile(
      path: ENV["IOS_PROVISIONING_PROFILE_PATH"]
    )
    
    profile_uuid = sh("security cms -D -i \"#{ENV['IOS_PROVISIONING_PROFILE_PATH']}\" | plutil -extract UUID xml1 -o - - | sed -n 's/.*<string>\\(.*\\)<\\/string>.*/\\1/p'").strip

    update_project_team(
      path: "Runner.xcodeproj",
      teamid: ENV["DEVELOPMENT_TEAM"]
    )
    
    update_code_signing_settings(
      path: "Runner.xcodeproj", 
      use_automatic_signing: false,
      targets: ["Runner"],
      code_sign_identity: "iPhone Distribution: Morris Merkel (QX8XC3CNTR)",
      profile_uuid: profile_uuid
    )

    # ALTERNATIVE METHOD: Manual Archive without problematic Build Phases
    UI.message("üî® Using alternative build method - manual xcodebuild archive...")
    
    # Set Flutter environment explicitly
    ENV['FLUTTER_ROOT'] = '/Users/runner/hostedtoolcache/flutter/3.24.3/x64'
    ENV['PATH'] = "#{ENV['FLUTTER_ROOT']}/bin:#{ENV['PATH']}"
    
    # Manual xcodebuild command bypassing Fastlane's build_ios_app
    archive_path = "fastlane/builds/Runner.xcarchive"
    
    sh("xcodebuild -workspace Runner.xcworkspace -scheme Runner -configuration Release -archivePath #{archive_path} archive CODE_SIGN_IDENTITY='iPhone Distribution: Morris Merkel (QX8XC3CNTR)' PROVISIONING_PROFILE='#{profile_uuid}' -allowProvisioningUpdates")
    
    # Manual export IPA
    ipa_path = "fastlane/builds/Lumengarten.ipa"
    export_options_plist = "fastlane/builds/ExportOptions.plist"
    
    # Create Export Options plist
    File.write(export_options_plist, <<-PLIST)
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>method</key>
    <string>app-store</string>
    <key>provisioningProfiles</key>
    <dict>
        <key>com.lumengarten.lumengartenApp</key>
        <string>#{profile_uuid}</string>
    </dict>
    <key>signingStyle</key>
    <string>manual</string>
    <key>uploadBitcode</key>
    <false/>
    <key>uploadSymbols</key>
    <true/>
</dict>
</plist>
PLIST
    
    sh("xcodebuild -exportArchive -archivePath #{archive_path} -exportPath fastlane/builds -exportOptionsPlist #{export_options_plist}")
    
    # Upload to TestFlight
    api_key = app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: "d439615c-03af-424b-8ed7-98abfae18d23",
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"],
      duration: 1200,
      in_house: false
    )
      
    upload_to_testflight(
      api_key: api_key,
      app_identifier: "com.lumengarten.lumengartenApp",
      skip_waiting_for_build_processing: true,
      ipa: ipa_path
    )

    # Cleanup
    delete_keychain(name: "fastlane_tmp_keychain")
  end
end