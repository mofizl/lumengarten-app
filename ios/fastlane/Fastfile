# Fastfile for Lumengarten iOS TestFlight Deployment

default_platform(:ios)

platform :ios do
  desc "Build and upload to TestFlight"
  lane :testflight do
    # Setup temporary keychain for CI
    create_keychain(
      name: "fastlane_tmp_keychain",
      password: ENV["KEYCHAIN_PASSWORD"],
      default_keychain: false,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    # Skip certificate import - try using API key only approach
    # import_certificate(
    #   certificate_path: ENV["IOS_CERTIFICATE_PATH"],
    #   certificate_password: ENV["IOS_CERTIFICATE_PASSWORD"],
    #   keychain_name: "fastlane_tmp_keychain",
    #   keychain_password: ENV["KEYCHAIN_PASSWORD"]
    # )

    install_provisioning_profile(
      path: ENV["IOS_PROVISIONING_PROFILE_PATH"]
    )

    # Update project settings for distribution
    update_project_team(
      path: "Runner.xcodeproj",
      teamid: ENV["DEVELOPMENT_TEAM"]
    )

    # Install CocoaPods dependencies first
    cocoapods(
      clean_install: true,
      repo_update: true
    )

    # Build Flutter app
    sh("flutter build ios --release --no-codesign")

    # Debug: Find where Flutter built the app (from root directory)
    sh("ls -la ../../build/")
    sh("ls -la ../../build/ios/")
    sh("find ../../build -name Runner.app -type d")
    
    # Create unsigned IPA from Flutter's build output
    # Flutter said it built to build/ios/iphoneos/Runner.app 
    sh("cd ../../build/ios/iphoneos && zip -r Runner.ipa Runner.app")
    sh("mkdir -p fastlane/builds && mv ../../build/ios/iphoneos/Runner.ipa fastlane/builds/Lumengarten.ipa")
    
    # Get absolute path to the IPA
    ipa_path = File.expand_path("fastlane/builds/Lumengarten.ipa")
    UI.message("Created unsigned IPA at: #{ipa_path}")
    
    # Debug environment variables
    UI.message("üîç Debug Environment Variables:")
    UI.message("APP_STORE_CONNECT_API_KEY_ID: #{ENV['APP_STORE_CONNECT_API_KEY_ID']}")
    UI.message("APP_STORE_CONNECT_API_KEY_PATH: #{ENV['APP_STORE_CONNECT_API_KEY_PATH']}")
    
    # Verify IPA exists before upload
    if File.exist?(ipa_path)
      UI.message("‚úÖ IPA file confirmed at: #{ipa_path}")
      
      # Check if API key file exists
      api_key_path = ENV["APP_STORE_CONNECT_API_KEY_PATH"]
      if api_key_path && File.exist?(api_key_path)
        UI.message("‚úÖ API Key file found at: #{api_key_path}")
      else
        UI.error("‚ùå API Key file not found at: #{api_key_path}")
        sh("find .. -name 'AuthKey*.p8' -type f")
      end
      
      # Debug environment access step by step
      UI.message("üîç Step 1: Accessing APP_STORE_CONNECT_API_KEY_ID...")
      
      begin
        key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
        UI.message("‚úÖ key_id retrieved: #{key_id.nil? ? 'NIL' : 'SET'}")
      rescue => e
        UI.error("‚ùå Failed to access APP_STORE_CONNECT_API_KEY_ID: #{e}")
        exit(1)
      end
      
      UI.message("üîç Step 2: Setting issuer_id...")
      issuer_id = "d439615c-03af-424b-8ed7-98abfae18d23"
      UI.message("‚úÖ issuer_id set: #{issuer_id}")
      
      UI.message("üîç Step 3: Accessing APP_STORE_CONNECT_API_KEY_PATH...")
      begin
        key_filepath = ENV["APP_STORE_CONNECT_API_KEY_PATH"]
        UI.message("‚úÖ key_filepath retrieved: #{key_filepath}")
      rescue => e
        UI.error("‚ùå Failed to access APP_STORE_CONNECT_API_KEY_PATH: #{e}")
        exit(1)
      end
      
      if key_id.nil? || key_id.empty?
        UI.error("‚ùå APP_STORE_CONNECT_API_KEY_ID is nil or empty!")
        exit(1)
      end
      
      # Upload unsigned IPA to TestFlight - App Store Connect handles signing
      # Use individual parameters instead of api_key hash to avoid Fastlane bug
      upload_to_testflight(
        api_key_path: key_filepath,
        api_key_id: key_id,
        api_key_issuer_id: issuer_id,
        skip_waiting_for_build_processing: true,
        ipa: ipa_path
      )
    else
      UI.error("‚ùå IPA file not found at: #{ipa_path}")
      sh("ls -la fastlane/builds/")
    end

    # Cleanup
    delete_keychain(name: "fastlane_tmp_keychain")
  end
end